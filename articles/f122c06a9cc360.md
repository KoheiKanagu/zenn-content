---
title: "FlutterとFirebaseを使ってアプリを作る上でのテクニックあれこれ"
emoji: "📘"
type: "tech"
topics: [flutter, firebase, githubactions]
published: true
---

# はじめに

この記事は[【Zenn 初開催】AI エージェント開発に挑戦！初心者歓迎ハッカソン](https://zenn.dev/hackathons/2024-google-cloud-japan-ai-hackathon)に提出した成果物である「BLOOMS」という Flutter を用いた iOS/Web アプリケーションで使用した、様々なテクニックについてまとめたものです。

BLOOMS が何なのか、についてはこちらの記事を参照してください。iOS 版と Web 版があるので、興味のある方はぜひお試しください。
https://zenn.dev/kingu/articles/a36196c5c66171

## 筆者について

2025 年現在、私はフリーランスのソフトウェアエンジニアとして活動しています。
主に Flutter を用いたモバイルアプリケーションを得意とし、必要に応じて Firebase を用いてバックエンドも構築しています。

細かい内容はポートフォリオをご覧ください(PR) https://kingu.dev

## この記事について

「BLOOMS」は私がこれまで個人開発や仕事で得た知識を活用して実装しており、言わば現在の私の集大成です。ソースコードも公開していますし、せっかくなのでどのようなテクニックを使っているのかをまとめてみようと思います。

BLOOMS のソースコードを交えつつ、できるだけなぜそのような判断になったのか理由も合わせて述べていきます。

:::message alert
それなりの信頼性はあると思いますが、厳密にテストしたわけではないので、参考にする際は自己責任でお願いします。
:::

:::message

初稿より、加筆修正が加えられている場合があります。
変更点はこちらをご確認ください。
https://github.com/KoheiKanagu/zenn-content/commits/master/articles/f122c06a9cc360.md
:::

## 前提

2025 年 2 月時点で有効な情報であり、BLOOMS のバージョン `1.0.1` 時点の話です。
https://github.com/KoheiKanagu/blooms/tree/v1.0.1

Flutter のバージョンは `3.27.2`、Dart のバージョンは `3.6.1`です。
https://github.com/KoheiKanagu/blooms/blob/v1.0.1/app/pubspec.yaml#L7-L9

これらのバージョンが上がったことによって使えなくなったり、挙動が変わる可能性もありますが、この記事では修正しませんのでご了承ください。

### 主なトピック

この記事で取り上げる内容は、ある程度知っている方を対象としているので初学者の方にとっては説明不足に感じるかもしれません。

順番にはあまり意味はありません。ざっくばらんに書いていきます。
長いので目次もご活用ください →

# Flutter の基本関連

## バージョンは固定する

バージョンは固定します。

https://github.com/KoheiKanagu/blooms/blob/v1.0.1/app/pubspec.yaml#L7-L9

`flutter create`で作成された`pubspec.yaml`には以下のように緩めに指定されていますが、緩くするメリットが無いように思っています。

```yaml
environment:
  sdk: ^3.6.1
```

というのも、以前[renovate](https://github.com/renovatebot/renovate)を使っていた時に[バージョンの範囲指定で問題](https://github.com/renovatebot/renovate/discussions/26346)があったり、FVM で Flutter をインストールするときに`fvm use stable`してしまうと、いつの間にかバージョンが上がっていたり、GitHub Actions で[flutter-action](https://github.com/marketplace/actions/flutter-action)を使う際に手元とは違うバージョンになってしまった事故が発生したので、固定するようにしています。

現在では`pubspec.yaml`はこのように固定し、

https://github.com/KoheiKanagu/blooms/blob/v1.0.1/app/pubspec.yaml#L7-L9

`.fvmrc`は`fvm use 3.27.2`を実行して固定し、
https://github.com/KoheiKanagu/blooms/blob/v1.0.1/app/.fvmrc#L1-L3

CI では[flutter-fvm-config-action](https://github.com/marketplace/actions/flutter-fvm-config-action)を用いて`.fvmrc`からバージョンを引っ張り、
https://github.com/KoheiKanagu/blooms/blob/v1.0.1/.github/workflows/pull_request.yml#L64-L68

[flutter-action](https://github.com/marketplace/actions/flutter-action)で参照しています。
https://github.com/KoheiKanagu/blooms/blob/v1.0.1/.github/workflows/pull_request.yml#L70-L78

これにより、`pubspec.yaml`と`.fvmrc`を更新しない限りバージョンは勝手に変わらないですし、手元の環境、開発メンバー、CI で同じバージョンが利用できます。
また、もしふとした拍子に`fvm use 3.29.0`などとしてしまった場合でも、`dart pub get`でエラーになるので気づきやすいです。

## [FVM](https://fvm.app/)を使う

前述していますが、Flutter のバージョン管理には FVM を利用しています。[asdf](https://asdf-vm.com/)も選択肢としてよく上がりますが、Flutter の管理のためだけなので FVM で良いかなと思っています。

既に nvm や rbenv をやめて asdf に寄せている方であれば、そのまま Flutter も管理すると楽かと思います。

FVM の問題として、[Homebrew をサポートしているので](https://fvm.app/documentation/getting-started/installation)`brew install fvm`でインストールできるのは良いのですが、FVM 自体が Dart を必要としているので、Flutter(Dart)をインストールするツールをインストールするために Dart をインストールする、という卵が先か鶏が先かのような状態になります。

![brew install fvmするとdartがインストールされる](https://storage.googleapis.com/zenn-user-upload/70604c402a6a-20250218.png)
_brew install fvm すると dart がインストールされる_

FVM は[マシン全体の Flutter バージョンも管理できますが](https://fvm.app/documentation/guides/global-configuration)、場合によっては Homebrew でインストールされた Dart と衝突して PATH が変になる場合があるので`brew unlink`するか、そもそも Homebrew で FVM をインストールするのはやめた方がいいかもしれません。

## ビルド番号は自動で

`pubspec.yaml`の `version`に`+20`のように書くと、[ビルド番号を設定できます](https://dart.dev/tools/pub/pubspec#version)。

```yaml
version: 1.0.1+20
```

`20`という値は `ios/Flutter/Generated.xcconfig`の`FLUTTER_BUILD_NUMBER`に埋め込まれます。

```ios/Flutter/Generated.xcconfig
FLUTTER_BUILD_NAME=1.0.1
FLUTTER_BUILD_NUMBER=20
```

この指定は私は不要だと思っています。
https://github.com/KoheiKanagu/blooms/blob/v1.0.1/app/pubspec.yaml#L5

この番号は機械的にバージョンの前後を表すために利用されているので、App Store や Play Store にアップロードする際に必ずこの番号をインクリメントしないと弾かれてしまいます。
メジャー・マイナー・パッチが変わるタイミングであれば一緒に手動で+1 すればいいのですが、問題はビルド番号だけのインクリメントが必要な場合です。

例えば次期バージョンをテストしたいので [TestFlight](https://developer.apple.com/jp/testflight/) や[Google Play の内部テスト](https://support.google.com/googleplay/android-developer/answer/9845334?hl=ja)で配布したい場合はあると思います。
何かしらバグや QA で問題があった場合、修正して再配布する必要がありますがビルド番号もインクリメントする必要があります。
別のメジャー・マイナー・パッチにする場合は一緒に+1 すれば良いですが、同じメジャー・マイナー・パッチを許容する場合は、ビルド番号をインクリメントするプルリクエストを作成してマージして...というステップが必要になってきます。

[Cider](https://pub.dev/packages/cider)などを使って CI で自動でインクリメントする方法もありますが、いずれにせよアプリの機能には関係のない部分で、TestFlight や Google Play に受け付けてもらうためだけに手間をかけるのは時間の無駄です。

とりあえずインクリメントできればいいので、Xcode Cloud でビルドする場合は Xcode Cloud に任せています。自動でインクリメントして App Store Connect にアップロードしてくれます。
https://developer.apple.com/documentation/xcode/setting-the-next-build-number-for-xcode-cloud-builds

BLOOMS は Android 未対応なので別のアプリの話になりますが、Android の場合はタイムスタンプを使って適当な値を入れると良いと思います。iOS でも Xcode Cloud を使わないならタイムスタンプを使う方法が考えられます。
https://github.com/KoheiKanagu/garage/blob/1791470276f3858f87daa19ebde0a314dade7e45/packages/obento/android/app/build.gradle#L49-L55

[Codemagic](https://docs.codemagic.io/knowledge-codemagic/build-versioning/)では自動でインクリメントしてくれる機能があるようなので、Codemagic を使う場合はこちらを使う方が良いかもしれません。

---

ちなみに`version`の`+20`を指定しない場合は、`FLUTTER_BUILD_NUMBER`には`1.0.1`が埋め込まれます。

```ios/Flutter/Generated.xcconfig
FLUTTER_BUILD_NAME=1.0.1
FLUTTER_BUILD_NUMBER=1.0.1
```

## 環境の選択は `--flavor` で

環境は最低でも本番環境とステージング環境ぐらいは用意すると思います。この環境を Android と Flutter では Flavor、iOS では Scheme と呼びます。

`flutter build`や `flutter run` などでは`--flavor`オプションを使って指定したり、`--dart-define`または`--dart-define-from-file`オプションを使う方法がよく見られますが、私は `--flavor`が良いと思っています。

https://docs.flutter.dev/deployment/flavors-ios
https://docs.flutter.dev/deployment/flavors

本番環境とステージング環境それぞれで使い分けたい値というのは、例えば API のエンドポイントやアプリ名、Firebase の設定などがあると思いますが、これらの値は 1 回設定したらそうそう変わらないはずです。
ですので、わざわざ`--dart-define`や`--dart-define-from-file`オプションを使って毎回指定せずとも`--flavor`で指定する方がシンプルですし、何の値を使い分けているのかを意識しなくてもよくなるので、分かりやすいように思います。

とはいえ、あまりターミナルで素の `flutter run`や`flutter build`は実行せず、`.vscode/launch.json`やスクリプトを用意すると思うので好みの世界かもしれません。

ただし、ビルドの度になんらかの値を変えたかったり、コミットしたくない情報がある場合は `--dart-define`や`--dart-define-from-file`オプションを使う方が良いと思います。

:::message alert
API キーなどの機密情報をコミットしたくないから`--dart-define`で渡そうと思っているなら、それはやめましょう。

機密情報の管理について調べていると"機密情報を安全に管理する方法" のような記事が見つかると思いますが、セキュアではありません。どうやっても解析されたら流出します。
そもそも機密情報をクライアントアプリに埋め込むのは間違っています。

[API キーの制限](https://developers.google.com/maps/api-security-best-practices?hl=ja#restricting-api-keys)のように API キーが所定のアプリだけで利用できるように制限する、あるいは[App Check](https://firebase.google.com/docs/app-check?hl=ja)で正規のアプリからのリクエストであることを検証しつつ、サーバで処理すべきです。
:::

### Xcode Cloud との相性は `--flavor`の方がいい

Xcode Cloud の設定をする時に Scheme が認識されるので、選ぶだけでアプリ名やアイコンなどが本番環境向けになります。
![Xcode Cloudの設定](https://storage.googleapis.com/zenn-user-upload/8bf593d8da10-20250218.png)
_Xcode Cloud の設定_

なお、[`ios/ci_scripts/ci_post_clone.sh`](https://developer.apple.com/documentation/xcode/writing-custom-build-scripts#Create-a-custom-build-script)では予め `--flavor prod`を指定して本番向けの`Generated.xcconfig`を生成しましょう。
https://github.com/KoheiKanagu/blooms/blob/v1.0.1/app/ios/ci_scripts/ci_post_clone.sh#L37

### Flutter で Flavor を使い分ける

Flutter 側で Flavor によって値を切り替える場合は`FLUTTER_APP_FLAVOR`という環境変数から flavor が参照できるので、enum を定義して使うと良いと思います。
https://github.com/KoheiKanagu/blooms/blob/v1.0.1/app/lib/constants/app_env.dart#L1-L16

### どうやって Flavor を構築するか

[flutter_flavorizr](https://pub.dev/packages/flutter_flavorizr)を使う方法も考えられますが、そもそも頻繁に更新するものではないですし、やっていることも難しいことではないので iOS と Android ネイティブに触れる機会としても自分で設定するのが良いと思っています。（めんどくさいだけです）

Flutter の公式ドキュメントで丁寧に説明されています。
https://docs.flutter.dev/deployment/flavors-ios
https://docs.flutter.dev/deployment/flavors

1 回理解してしまえばサッサと対応できるようになると思いますが、iOS や Android のネイティブに慣れていないとややこしい部分もあるので、初学者の方は素直に`flutter_flavorizr`を使う方が簡単かもしれません。

## 各種コマンドは`*.sh`を用意しておく

`flutter run`や`flutter build`などのコマンドはターミナルに打ち込むのが面倒ですし、毎回オプションを指定するのも面倒でミスの原因にもなります。

`dart run build_runner build`や`flutter test`、`dart analyze`など、よく使うものはそれぞれのシェルスクリプトを用意すると良いと思います。これらは手元のマシンで実行したり、CI でも同じものを利用できます。
https://github.com/KoheiKanagu/blooms/tree/v1.0.1/app/scripts

例えばプルリクエストの際に実行されるジョブでは、静的解析やコード生成、テストなどを並列に実行しています。
https://github.com/KoheiKanagu/blooms/blob/v1.0.1/.github/workflows/pull_request.yml#L40-L48

https://github.com/KoheiKanagu/blooms/blob/v1.0.1/.github/workflows/pull_request.yml#L91-L98

### USE_FVM とは？

`USE_FVM`という謎の環境変数が出てきていますが、これは FVM を使って`flutter`や`dart`コマンドを実行するかを指定するものです。

https://github.com/KoheiKanagu/blooms/blob/v1.0.1/app/scripts/build_runner-build.sh#L4-L13

前述したように FVM で Flutter のバージョン管理をしているため、`dart run build_runner build`などではグローバル環境の Flutter ではなく、FVM で管理している Flutter を使って欲しいです。

そこで`USE_FVM`を`true`あるいは未指定にしておくと、`flutter`コマンドを実行する場合は暗黙的に`fvm flutter`となるように関数を定義しています。

スクリプト内では`fvm flutter test`のように頭に`fvm`をつければいいじゃないかと思いますが、CI ではわざわざ FVM をインストールしなくても[subosito/flutter-action](https://github.com/marketplace/actions/flutter-action)でグローバルにインストールされた Flutter を使えばいいので、FVM は不要です。

https://github.com/KoheiKanagu/blooms/blob/v1.0.1/.github/workflows/pull_request.yml#L70-L78

よって、CI では `USE_FVM`を`false`にしてグローバルにインストールされた Flutter を使っています。

### シェルスクリプトか[Grinder](https://pub.dev/packages/grinder)か

Grinder は Dart で実装できるタスクランナーですが、私は昔こちらを使っていました。
ですが、複雑なシェル芸をしないのであればシェルスクリプトで十分です。

各種コマンドをまとめているだけであれば Grinder を使うとむしろ分かりにくくなりますし、場合によっては PATH 周りでハマることもありました。
https://github.com/KoheiKanagu/garage/blob/1791470276f3858f87daa19ebde0a314dade7e45/tool/firebase/flutterfire_configure.dart#L17-L42

## `flutterfire_cli`を使おう

`flutterfire_cli`を利用すると、Firebase SDK の構成ファイルのダウンロード、Firebase へのアプリの登録、Crashlytics のセットアップなどを簡単に行うことができます。
https://github.com/invertase/flutterfire_cli
https://firebase.google.com/docs/flutter/setup?hl=ja&platform=ios

とても便利なので使いましょう。
私はよく`flutterfire_configure.sh`というスクリプトを用意しています。`BUNDLE_ID`や`PROJECT_NAME`を指定するだけで、全部やってくれます。（Flavor 対応で所定の Scheme を作成した後に実行できます）

頻繁に実行するようなものではありませんが、利用する Firebase のプロダクトを追加した時などは構成ファイルの更新が必要になるので、その時はこのスクリプトで一発です。
https://github.com/KoheiKanagu/blooms/blob/v1.0.1/app/scripts/flutterfire_configure.sh

上記の`flutterfire_configure.sh`は Android は未対応ですが、以下のように追加すれば良いです。詳しくは`flutterfire_cli`のドキュメントを参照してください。

```sh
--android-package-name $PACKAGE_NAME \
--android-out "android/app/src/prod/google-services.json`
```

## i18n は[slang](https://pub.dev/packages/slang)パッケージを使う

Internationalization にはいくつか方法がありますが、私は slang をよく使います。（大抵の場合は日本語と英語で出し分けるぐらいしかしていないので、使いこなせてる感じではありません。）
https://github.com/KoheiKanagu/blooms/blob/v1.0.1/app/lib/i18n/ja.i18n.json

slang は Flutter に依存していないので`BuildContext`が不要な点が良いと思っています。

`BuildContext`が不要なので enum の中でも参照できます。例えば、こちらはとある enum に生やしている getter ですが、`i18n.highlight.*`の値は`当日`や`過去7日間`などになります。
https://github.com/KoheiKanagu/blooms/blob/v1.0.1/app/lib/features/highlight/domain/highlight_period.dart#L26-L34

https://github.com/KoheiKanagu/blooms/blob/v1.0.1/app/lib/gen/strings_ja.g.dart#L79-L83

また、翻訳に過不足があると[コンパイルエラーになるので](https://pub.dev/packages/slang#-fallback)、取りこぼしがないかも確認しやすいです。[ARB にも対応しているので](https://pub.dev/packages/slang#arb)、翻訳を外部に依頼する場合でも対応しやすいと思います。

## Linter は厳しめに

最近は[Very Good Analysis](https://pub.dev/packages/very_good_analysis)を使っています。

[2021 年 9 月にリリースされた Flutter 2.5](https://medium.com/flutter/whats-new-in-flutter-2-5-6f080c3f3dc)からは`flutter create`すると Flutter 公式の[flutter_lints](https://pub.dev/packages/flutter_lints)が設定されているのでそのまま使ったり、[pedantic_mono](https://pub.dev/packages/pedantic_mono)を使う選択肢もあります。
正直ここはチームの方針や好みによるので議論が絶えませんが、個人的には厳しいルールの方が良いと思っています。

ひとまず厳しいルールにしておいて、どうしても対応するのが大変なルールは除外すると良いでしょう。なお、`analyzer.exclude`で余計なファイルは除外しておくとパフォーマンス的にも良いです。

https://github.com/KoheiKanagu/blooms/blob/v1.0.1/app/analysis_options.yaml

## コード生成の高速化

有名な話ですが、`riverpod_generator`や`freezed`などコード生成が伴うパッケージを使っている場合は`build.yaml`でコード生成対象を絞ると高速化できます。[`include`や`exclude`で指定しましょう。](https://pub.dev/packages/build_config#dividing-a-package-into-build-targets)

https://github.com/KoheiKanagu/blooms/blob/v1.0.1/app/build.yaml#L14-L21

build_runner 自体の高速化について[議論が進んでいるようなので](https://github.com/dart-lang/build/issues/3800)、近いうちに改善されるかもしれません。

## プロジェクトの構造は Feature-first

議論が絶えないトピックではありますが、個人的には Feature-first が良いと思っています。
https://codewithandrea.com/articles/flutter-project-structure/

良いと思う点は機能毎にソースコードがまとまるので、実装する際に確認すべきソースコードがどこにあるのか見つけやすいです。

例えばこちらは BLOOMS のハイライト機能に関する内容ですが、ドメイン、ウィジェット、ビジネスロジックのソースコードが近くにあるので分かりやすいと思っています。
![Feature-firstで構成されたBLOOMSのハイライト機能](https://storage.googleapis.com/zenn-user-upload/8a75ac201d9f-20250220.png =400x)
_Feature-first で構成された BLOOMS のハイライト機能_

## stable チャンネル？beta チャンネル？

私は個人開発なら beta、仕事なら stable を使っていることが多いです。

stable チャンネルは当然ですが、安定版なので最も安心です。（とはいえ[結構頻繁に Hotfix がリリース](https://github.com/flutter/flutter/blob/master/CHANGELOG.md)されていますが...）
beta チャンネルも [Google 製品のテストで検証されている](https://docs.flutter.dev/release/upgrade#switching-flutter-channels:~:text=This%20channel%20has%20passed%20all%20our%20public%20testing%2C%20has%20been%20verified%20against%20test%20suites%20for%20Google%20products%20that%20use%20Flutter%2C%20and%20has%20been%20vetted%20against%20contributed%20private%20test%20suites.)ので、比較的安定しているんじゃないかと思っています。何より新しい機能を先取りできるのがいいですね。

どの程度の信頼性が欲しいかによって選択すると良いと思います。

https://docs.flutter.dev/release/upgrade#switching-flutter-channels

BLOOMS では、当初[beta を使っていましたが](https://github.com/KoheiKanagu/blooms/pull/16)、analyzer が遅くてストレスフルだったので[1 日で stable に戻しました。](https://github.com/KoheiKanagu/blooms/pull/19)

# 適当なアイコンをさっと作る

:::message
自分で適当にアイコンを用意する必要がある場合の話です。ちゃんとする場合はプロに頼みましょう。
:::

BLOOMS のアイコンは Gemini に頼んで作ってもらったものをベースに、[Graphite](https://graphite.rs/)で手動でベクタライズしています。
ベクター化は [Adobe Illustrator](https://www.adobe.com/jp/products/illustrator.html) とか [GIMP](https://www.gimp.org/) でもいいと思いますが、ブラウザで動く Graphite が楽でした。まだまだ開発途中という感じですが、複雑なことをするわけではないので十分です。

ダークモードに適しているのかよく分からないですが、とりあえずダークモードにも対応しました。

| ライト                                                                                               | ダーク                                                                                                               |
| ---------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------- |
| ![BLOOMSのアイコン](https://storage.googleapis.com/zenn-user-upload/d7a8d5c946c3-20250218.png =200x) | ![BLOOMSのダークモード向けアイコン](https://storage.googleapis.com/zenn-user-upload/8fee1df36601-20250220.png =200x) |

できたアイコンを[IconKitchen](https://icon.kitchen/)で所定のサイズにリサイズしたり、STAGING というバッジを付けてステージング環境のアプリでは切り替えています。IconKitchen は文字のバッジが追加できるのが便利ですね。
自作のアイコンではなく、適当な図形で良ければ IconKitchen だけで作るのもありです。

![BLOOMSのステージングのアイコン](https://storage.googleapis.com/zenn-user-upload/bd28f125d45b-20250218.png =200x)
_BLOOMS のステージングのアイコン_

最近知った[Icon Maker by Raycast](https://ray.so/icon)もカッコよくて良さそうです。（でもバッジって付けられないですよね多分）

# 成果物はどこでビルドする？

成果物とは App Store Connect や Google Play Console にアップロードするためのバイナリのことを指しています。

## iOS は Xcode Cloud

iOS の場合は証明書とプロビジョニングプロファイルが必要なので、Xcode Cloud をよく利用します。
25 コンピューティング時間/月が無料なので、成果物をビルドするだけであれば個人開発や小規模なチームであれば十分だと思います。機密情報を GitHub Actions に渡さなくてもいいのも安心です。
https://developer.apple.com/jp/xcode-cloud/

手動や特定のタグの変更をトリガーとして実行できるので、[Release](https://github.com/KoheiKanagu/blooms/releases)を作ったらビルドされ、TestFlight で配信されるようにすると良いと思います。

![タグをトリガーとした設定](https://storage.googleapis.com/zenn-user-upload/830c3ec14acd-20250218.png)
_タグをトリガーとした設定_

https://zenn.dev/miyasic/articles/flutter-xcode-cloud

macOS や Xcode のバージョン指定も簡単にできるので便利ですね。
![macOSのバージョン指定](https://storage.googleapis.com/zenn-user-upload/d25bbd813efe-20250218.png)
_macOS のバージョン指定_
![Xcodeのバージョン指定](https://storage.googleapis.com/zenn-user-upload/711358b2877e-20250218.png)
_Xcode のバージョン指定_

---

余談ですが 2022 年時点では Intel Mac が利用されていたようです。
現在は Apple シリコンになっているでしょうが、次第にマシンスペックも上がっていくのでしょうか？
https://wojciechkulik.pl/xcode/xcode-cloud-review-is-it-ready-for-commercial-projects#xcode-cloud-m1

## Android は悩ましい

Android の場合は iOS よりも署名関連はまだ簡単ですが Google Play Console へのアップロードを考えると、[アップロード鍵](https://developer.android.com/studio/publish/app-signing?hl=ja)の管理が悩ましいです。

GitHub Actions で iOS の証明書などを管理する方法と同じように BASE64 でエンコードしてシークレットに登録して都度デコードし、成果物は[GitHub Action の Artifacts](https://docs.github.com/ja/actions/writing-workflows/choosing-what-your-workflow-does/storing-and-sharing-data-from-a-workflow)に保存する方法も考えられます。[Fastlane を使って](https://docs.fastlane.tools/actions/upload_to_play_store/)直接アップロードしてもいいと思います。

https://docs.github.com/ja/actions/use-cases-and-examples/deploying/installing-an-apple-certificate-on-macos-runners-for-xcode-development

しかし、パブリックリポジトリの場合は事故りそうで怖いです。
GitHub Actions ではない CI/CD を使ったり、[自己ホストランナー](https://docs.github.com/ja/actions/hosting-your-own-runners/managing-self-hosted-runners/about-self-hosted-runners)でビルドするのが良いかもしれません。

---

以前は手元のマシンでビルドとアップロードをやっていました。個人開発なら多分これが一番早いと思います。が、属人化するのでやめましょう。
https://github.com/KoheiKanagu/garage/blob/1791470276f3858f87daa19ebde0a314dade7e45/melos.yaml#L139-L147

https://github.com/KoheiKanagu/garage/blob/1791470276f3858f87daa19ebde0a314dade7e45/tool/store/upload_to_play_store.sh

# GitHub Actions ではキャッシュを活用しよう

CI でのビルド時間の短縮は重要です。プルリクエスト毎にクリーンな環境はそれはそれで綺麗なのですが、キャッシュできる部分はキャッシュしてしまった方が開発サイクルが速くなるのでメリットが大きいと思っています。

私がよくやるのは、main ブランチへの Push をトリガーとして、依存ライブラリや Flutter のバージョンが変わった場合にビルドして`pub`や`ios/Pods`をキャッシュする方法です。
https://github.com/KoheiKanagu/blooms/blob/32f20eb3125d0316f845ec1132bc4d2c62408f83/.github/workflows/flutter_cache.yml

これにより各種プルリクエストではキャッシュを使ってビルドすることができるため、ビルド時間が短縮されます。
まだ遭遇したことはありませんが、もしキャッシュが悪さをしている事態になった場合は、[キャッシュを削除](https://docs.github.com/ja/actions/writing-workflows/choosing-what-your-workflow-does/caching-dependencies-to-speed-up-workflows#deleting-cache-entries)すればクリーンな状態でビルドできます。

もし不安ならキャッシュを使わずビルド・テストするワークフローも用意して、デイリーで実行するなどして確認すると良いと思います。

## 不要なキャッシュは削除しよう

GitHub Actions のキャッシュは[最大 10GB まで](https://docs.github.com/ja/actions/writing-workflows/choosing-what-your-workflow-does/caching-dependencies-to-speed-up-workflows#usage-limits-and-eviction-policy)ですが、作成される複数のキャッシュは[100MB〜1GB 程度あるので](https://github.com/KoheiKanagu/blooms/actions/caches?query=branch%3Amain)結構すぐ上限に達します。（使っているパッケージの量に依存します）

特に[Dependabot](https://docs.github.com/ja/code-security/dependabot/working-with-dependabot)を使って依存ライブラリのアップデートを行なっていると`pubspec.yaml`が変わるので新しくキャッシュが作成されることになり、キャッシュまみれになります。

プルリクエストがマージされたら、そのブランチのキャッシュは不要なので削除しましょう。
https://github.com/KoheiKanagu/blooms/blob/v1.0.1/.github/workflows/cleanup_caches_by_a_branch.yml

ポイントは`permissions`で、これがないと Dependabot が作成したプルリクエストがマージされた際にキャッシュを削除できません。

```yaml
permissions:
  actions: write
```

---

とはいえ、7 日間アクセスされていなければ古いものから勝手に削除されていくので、キャッシュ作成の頻度によっては気にしなくても問題ないと思います。

https://docs.github.com/ja/actions/writing-workflows/choosing-what-your-workflow-does/caching-dependencies-to-speed-up-workflows#usage-limits-and-eviction-policy

# アプリの見た目関連

## Cupertino ウィジェットを使う

Flutter は基本的には Material デザインである Material ウィジェットですが、Apple ライクな Cupertino ウィジェットも用意されています。
https://docs.flutter.dev/ui/widgets/cupertino

2024 年 12 月に安定版となった[Flutter 3.27](https://medium.com/flutter/whats-new-in-flutter-3-27-28341129570c)や、2025 年 2 月に安定版となった[Flutter 3.29](https://medium.com/flutter/whats-new-in-flutter-3-29-f90c380c2317)では、Cupertino ウィジェットの忠実度が向上したり、[showCupertinoSheet](https://main-api.flutter.dev/flutter/cupertino/showCupertinoSheet.html)が追加されたりと、Cupertino ウィジェットにも力が入っているような気がします。

せっかくなので、BLOOMS では Cupertino ウィジェットを使って実装しています。
しかし、iOS でお馴染みのコンポーネント全てが Cupertino ウィジェットで実装されているわけではないので、一部はサードパーティのパッケージを利用しました。

https://pub.dev/packages/pull_down_button
https://pub.dev/packages/cupertino_calendar_picker

Flutter 3.27 で[Impeller](https://docs.flutter.dev/perf/impeller)が利用できるようになったこともあり、パフォーマンスも良く、結構それっぽくなりました。iOS 版の BLOOMS で実際に見てみてください。

デザインとしては当然ですが Apple のアプリのようになるので、デザイナーの方のデザインに沿って実装する場合は Material ウィジェットの方が使い勝手がいいと思います。
ただ、ダイアログや画面遷移の仕方などはプラットフォームに沿った方がユーザにとって違和感がないと思うので、デザイナーの方と相談して使い分けると良いと思います。

### Cupertino Icons

Apple ライクなアイコンも使いたいですよね？
Apple が提供している SF Symbols はバリエーションも多く、高品質なのですが規約的に使えません。
https://developer.apple.com/jp/sf-symbols/

そこで似た感じのアイコンを提供しているのが[cupertino_icons](https://pub.dev/packages/cupertino_icons)です。もちろん規約的にも OK です。
しかしめちゃくちゃ探し難いので、Cupertino Icons Gallery を使いましょう。
https://cupertino-icons.web.app/

---

昔[`car`アイコンが重なっているバグ](https://github.com/flutter/flutter/issues/98029)があったり、[`car_detailed`](https://api.flutter.dev/flutter/cupertino/CupertinoIcons/car_detailed-constant.html)がなぜか TESLA っぽかったりします。

![TESLAっぽいcar_detailedアイコン](https://storage.googleapis.com/zenn-user-upload/4282ff2d7785-20250220.png =200x)
_TESLA っぽい car_detailed アイコン_

## 日本語のテキストをいい感じに折り返す

日本語のテキストは単語の途中で改行されると読みづらくなります。

最近では、[BudouX](https://github.com/google/budoux)という機械学習を使って分かち書きができるツールが登場し、Web 系や Android で採用されています。
https://developers-jp.googleblog.com/2023/09/budoux-adobe.html

BLOOMS では、オンボーディングのサブタイトルだけ BudouX を使っています。
「見つめてみよう〜」のテキストはうまいこと改行されていますが、「変化しやすい体調も〜」の文章は単語の途中で改行されてしまっているのが分かります。
![いい感じに折り返されるテキスト](https://storage.googleapis.com/zenn-user-upload/1b5d7f1ab369-20250218.webp =400x)
_いい感じに折り返されるテキスト_

なお BudouX 公式では 2025 年 2 月現在 Dart はサポートされていませんが、私が移植したパッケージで利用できます。ご興味がある方はどうぞ。
https://pub.dev/packages/budoux_dart

## BlurHash で綺麗なプレースホルダー

BlurHash は[画像を変換して Base83 でエンコード](https://github.com/woltapp/blurhash/blob/master/Algorithm.md)することで、元の画像の特徴を保ったまま軽量なプレースホルダーを文字列で表現することができます。
https://blurha.sh/

![BlurHashで読み込まれる画像](https://storage.googleapis.com/zenn-user-upload/3e8c9c1202a2-20250218.webp =400x)
_BlurHash で読み込まれる画像_

最初プリンの画像がぼんやりしているのは BlurHash が表示されており、後から画像が読み込まれて鮮明になっています。

このプリンの BlurHash は `LDJ7s_$#~U.7RjWW$%xZ?Gxu8^M{`であり、非常に軽量です。
ただの文字列なので、サーバからデータをもらう際に一緒にこの BlurHash の文字列を含めておけば、サムネイル画像を読み込むなどの処理をしなくとも瞬時にプレースホルダーとして表示できます。

Flutter においては [flutter_blurhash](https://pub.dev/packages/flutter_blurhash) パッケージを利用すると良いと思います。

### どこで BlurHash を生成するか

サーバでやった方がいいです。
[Dart でエンコードするパッケージ](https://pub.dev/packages/blurhash_dart)もありますが、遅いという点とサポートしている画像の形式が限られます。

BLOOMS ではカメラやフォトライブラリから画像を受け取ったら、Cloud Functions に投げてリサイズ、WebP にエンコード、Google Storage に保存、BlurHash の生成を行なっています。

https://github.com/KoheiKanagu/blooms/blob/v1.0.1/firebase/functions/src/features/image/processConditionContentImage.ts#L12-L82

# Cloud Functions 関連

## Cloud Functions で Firestore を使う際のコールドスタート高速化

Cloud Functions で Firestore を使う場合、そのままだと gRPC の初期化が走ってしまい、コールドスタートが遅くなります。
gRPC が必要になる機会はあまりないと思うので、[preferRest](https://firebase.google.com/docs/reference/admin/node/firebase-admin.firestore.firestoresettings?hl=ja)を`true`にして高速化しましょう。
https://github.com/KoheiKanagu/blooms/blob/v1.0.1/firebase/functions/src/index.ts#L8-L10

https://www.youtube.com/watch?v=9nkAGR5Qe2A&t=45s

# Firestore 関連

## データ構造を考えるときは OpenAPI ドキュメント で作る

Firestore のデータ構造を設計するときは、みなさんどうやってますか？
ER 図を書くのも手だと思いますが、私は最近 OpenAPI ドキュメントでいいんじゃないかと思っています。（公式ツールとかベストプラクティスって無いですよね？）

[Firestore のデータの構造](https://firebase.google.com/docs/firestore/manage-data/structure-data?hl=ja)はドキュメントとコレクションの繰り返しで構成されているので URI として表現できるはずですし、ドキュメントはほぼ JSON なので OpenAPI ドキュメント で表現できるように思います。

BLOOMS の Firestore のデータ構造はこのようになっています。
https://github.com/KoheiKanagu/blooms/blob/v1.0.1/firebase/firestore/schemas.yml

[昔は JSON5 で書いていたこと](https://github.com/KoheiKanagu/garage/blob/main/firebase/firestore/default.model.json5)もありましたが、OpenAPI ドキュメントの方がリッチですし、Swagger UI もあるので確認しやすい気がします。

![Swagger UI](https://storage.googleapis.com/zenn-user-upload/cc34092fb268-20250218.png)
_Swagger UI_

ここからデータモデルを生成できれば、Flutter と Cloud Functions で共通にできるので管理しやすそうですが、どうなんでしょうか？[freezed](https://pub.dev/packages/freezed)と共存できるなら良いのですが...

## データの作成者は createdBy で判定

このドキュメントは誰が作ったのか、どのユーザに紐づいているのかを把握する状況はよくあります。

いくつか考えられる仕様はありますが、私は`createdBy`というフィールドに Firebase Authentication の UID を入れる方法をよく取ります。
セキュリティルールとの相性もよく、クエリもしやすいと思います。

https://medium.com/firebase-developers/patterns-for-security-with-firebase-per-user-permissions-for-cloud-firestore-be67ee8edc4a

とはいえ、サービスの要件によりけりなので、最適かどうかは十分検討が必要です。

## データの削除は TTL

データを論理削除する場合は`deletedAt`のようなフィールドにフラグを立てたり、時刻を入れるのがよくあると思います。

Firestore では Timestamp を入れるのが良いと思います。
というのも、Firestore には特定のフィールドの Timestamp の値が過去になった場合に自動で物理削除してくれる機能があり、こちらと相性が良いです。
https://cloud.google.com/firestore/docs/ttl?hl=ja

一定期間保持した後に削除したい、といった場合には`deletedAt`に入れる時刻を工夫すると実現できます。何より自分で削除する実装を行わなくていいので楽です。

BLOOMS ではユーザが削除する操作を行なった場合は`deletedAt`に現在時刻を入れることで、24 時間以内に物理削除されるようにしています。
https://github.com/KoheiKanagu/blooms/blob/v1.0.1/firebase/firestore/schemas.yml#L53-L56

## ユーザデータの削除

ユーザがアカウントを削除する操作を行なった場合は、そのユーザに紐づくデータも削除する必要があります。

ユーザがアカウントを削除する操作を行うと、そのユーザ固有のドキュメント `users_v1/{UID}` の`deletedAt`フィールドに現在時刻を書き込みます。
`deletedAt`に値があるユーザは削除されたものとみなし、Cloud Functions で定期的に Firebase Authentication から削除します。

https://github.com/KoheiKanagu/blooms/blob/v1.0.1/firebase/functions/src/features/auth/application/onUserDeleteSchedule.ts#L6-L28

この時のポイントは、Firebase Authentication からは一人ずつ削除することです。

---

関連するデータの削除には、Delete User Data 拡張機能を使います。この機能拡張は Firebase Authentication のユーザ削除をトリガーとして、関連するコレクションや Cloud Storage に保存されたファイルなど一括で削除してくれます。
https://firebase.google.com/docs/extensions/official/delete-user-data?hl=ja

具体的には`functions.auth.user().onDelete`トリガーを利用しているため、`onDelete`が呼ばれる必要があります。

https://github.com/firebase/extensions/blob/d7bdc93c3a809114b3ae571f5b5d510c3ee57f7c/delete-user-data/functions/src/index.ts#L193-L198

しかし、`getAuth().deleteUsers()`を使って Firebase Authentication から一気にユーザを削除してしまうと[`onDelete`が呼ばれないため](https://firebase.google.com/docs/auth/admin/manage-users?hl=ja#delete_multiple_users)、注意が必要です。

---

Delete User Data 拡張機能では、Cloud Storage に保存されたファイルも削除してくれますが、`/images_v1/{UID}`のように UID でディレクトリを分けて保存している必要があります。設計に関わってくるので、もし使うなら最初から考慮しておくと良いでしょう。

BLOOMS では次のように指定しています。
https://github.com/KoheiKanagu/blooms/blob/v1.0.1/firebase/extensions/delete-user-data.env

# Firebase Extensions 関連

## Cloud Functions がデプロイされるロケーションを指定する

こちらの謎の 3 行でロケーションを指定することができます。
https://github.com/KoheiKanagu/blooms/blob/v1.0.1/firebase/extensions/delete-user-data.env#L9-L11

デフォルトだと Firebase Extensions の関数は us-central1 にデプロイされてしまいます。Extensions を構成する際にロケーションを指定できる場合もありますが、Extensions の構成パラメータで定義されている必要があります。

例えば[Delete User Data 機能拡張](https://extensions.dev/extensions/firebase/delete-user-data)では Firestore のパスが指定できますが、これは`extensions.yaml`の params に`FIRESTORE_PATH`として定義されています。
https://github.com/firebase/extensions/blob/delete-user-data-v0.1.24/delete-user-data/extension.yaml#L88-L104

実は params に定義されていなくても、これ以外のパラメータも指定することができます。
`firebaseextensions.v1beta.v2function` は[第 2 世代の Cloud Functions に関する設定](https://firebase.google.com/docs/extensions/reference/extension-yaml?hl=ja#2nd-gen)を指しており、location をオーバーライドすることができます。

こちらの issue で発見された解決策です。
https://github.com/firebase/extensions/issues/1750#issuecomment-1761102399

## Firebase CLI で機能拡張をデプロイできない場合がある

Cloud Storage のデフォルトのバケット名が 2024 年 9 月に変更されました。この影響で `firebase deploy --only extensions`とするとバリデーションエラーとなり、デプロイできない事態になっていました。

報告したところすぐに対応してもらえました。[v13.30.0](https://github.com/firebase/firebase-tools/releases/tag/v13.30.0)で修正されたのでバージョンアップしましょう。
https://github.com/firebase/firebase-tools/issues/8152

# Firebase Hosting 関連

今回、Firebase Hosting を使って 3 つのサイトをホストしています。

- BLOOMS の Web 版: https://app.blooms.kingu.dev
- [widgetbook](https://pub.dev/packages/widgetbook): https://widgetbook.blooms.kingu.dev
- LP や Q&A のページ(TODO): https://blooms.kingu.dev

Firebase Hosting の[デプロイターゲット](https://firebase.google.com/docs/cli/targets?hl=ja)を使うと、1 つのプロジェクトで[複数のサイトをホストできます](https://github.com/KoheiKanagu/blooms/blob/v1.0.1/firebase/.firebaserc#L7-L34)。

# GitHub Actions で Firebase Deploy

## OIDC を使おう

GitHub Actions から Firebase にデプロイする際には、[Firebase CLI](https://firebase.google.com/docs/cli?hl=ja)を使ってデプロイします。この時、該当する Firebase プロジェクトにアクセスするため、なんらかの認証情報が必要です。

以前は[`FIREBASE_TOKEN`](https://firebase.google.com/docs/cli?hl=ja#cli-ci-systems-firebase-token)を使う方法が一般的でしたが、[2021 年 12 月に OIDC](https://cloud.google.com/blog/ja/products/identity-security/enabling-keyless-authentication-from-github-actions)が導入されたため、より安全にアクセスできるようになりました。

当初は（確か）一部リソースのデプロイが未対応だったり、[Admin SDK が対応しておらず](https://github.com/firebase/firebase-admin-node/issues/1377)テストが動かないため、やむを得ず`FIREBASE_TOKEN`を使っていました。最近は OIDC が原因の問題に遭遇していないので多分 OIDC だけで大丈夫だと思います。

https://docs.github.com/ja/actions/security-for-github-actions/security-hardening-your-deployments/configuring-openid-connect-in-google-cloud-platform

---

セットアップがやや面倒ですが、gcloud コマンドで一気に設定できるようにしたスクリプトを用意しています。手元のマシンで実行したり、Cloud Shell で実行すると良いでしょう。
https://gist.github.com/KoheiKanagu/a7ba42bde25f8fb10abb673c4fb8154c

何をしているのかについては参考文献をご覧ください。
https://zenn.dev/kou_pg_0131/articles/gh-actions-oidc-gcp

セットアップが完了したら、次のように[Authenticate to Google Cloud](https://github.com/marketplace/actions/authenticate-to-google-cloud)アクションで認証情報を取得できます。
https://github.com/KoheiKanagu/blooms/blob/v1.0.1/.github/workflows/firebase_deploy.yml#L55-L60

## run-name を動的に変えてデプロイ先を表示

GitHub Actions の小技ですが、実は[`run-name`は動的に変えることができます。](https://docs.github.com/ja/actions/writing-workflows/workflow-syntax-for-github-actions#run-name)

本番環境向けとステージング環境向け、それぞれデプロイするワークフローを実装するのは管理が大変になるのでできるだけ共通化したいです。ですが、同じ`run-name`だとどの環境でデプロイされたのか分かりにくいです。

`inputs.environment`から取得した環境名を`run-name`に渡せば、[名前を変えることができます](https://github.com/KoheiKanagu/blooms/actions/workflows/firebase_deploy.yml)。
https://github.com/KoheiKanagu/blooms/blob/v1.0.1/.github/workflows/firebase_deploy.yml#L3-L14

![inputs.environmentに応じてrun-nameが変わった様子](https://storage.googleapis.com/zenn-user-upload/80eede164997-20250220.png)
_inputs.environment に応じて run-name が変わった様子_

何のワークフローをどこの環境で実行したのか一目で分かるので便利です。

---

OIDC の`WORKLOAD_IDENTITY_PROVIDER`と`SERVICE_ACCOUNT`は次のように環境毎に切り替えています。（二値なのでまだましですが、条件分岐が増えると分かりにくくなるので考え直す必要はあります。）
https://github.com/KoheiKanagu/blooms/blob/v1.0.1/.github/workflows/firebase_deploy.yml#L20-L23

# アプリが起動した時に行うこと関連

## 読み込み画面を出しつつ初期化する

こちらの記事を参考にしています。
https://codewithandrea.com/articles/robust-app-initialization-riverpod/

要はスプラッシュスクリーンの状態で様々な初期化を行うのではなく、スプラッシュスクリーンでは最低限の初期化だけを行い、読み込み画面を表示させたら他の初期化を実行し、全て完了したらメイン画面、またはエラーページに遷移させましょうというものです。

BLOOMS では`main`から`runApp`までの間に行なっている初期化は`Firebase.initializeApp`や Locale といった最低限のものだけです。もしこれらの初期化が失敗した場合はアプリはクラッシュしたりフリーズしても良いレベルのエラーです。
https://github.com/KoheiKanagu/blooms/blob/v1.0.1/app/lib/main.dart#L19-L41

[go_router](https://pub.dev/packages/go_router)使っているので間は省きますが、runApp されたら`AppStartupWidget`が表示されます。
https://github.com/KoheiKanagu/blooms/blob/v1.0.1/app/lib/features/startup/presentation/startup_page.dart#L9-L26

`appStartUpProvider`でその他の初期化処理を行なっており、Provider の状態に応じて読み込み画面、エラーページを表示します。初期化が完了した場合は go_router のリダイレクトでオンボーディングかメインの画面に遷移します。
https://github.com/KoheiKanagu/blooms/blob/v1.0.1/app/lib/features/startup/application/app_startup.dart#L16-L98

もし`appStartUpProvider`でエラーが発生した場合は、`ref.invalidate(appStartUpProvider)`で破棄すれば再度初期化することもできます。

前述の記事で詳しく解説されているので、興味があれば読んでみてください。

### Transition は控えめに

デフォルトの Transition は画面横からスライドしてきますが、これだとアニメーションが激しいのでアプリを起動する度にウワッとなります。
[NoTransitionPage](https://github.com/KoheiKanagu/blooms/blob/v1.0.1/app/lib/features/startup/application/startup_page_route.dart#L15)や[FadeTransition](https://github.com/KoheiKanagu/blooms/blob/v1.0.1/app/lib/features/home/application/home_route.dart#L21)でスムーズに切り替わるようにすると良いと思います。

### 読み込み画面はそもそも必要なのか？

個人的にはあった方がなんとなく起動してますよ感があるのでユーザも安心できると思っています。
スプラッシュスクリーンのままでしばらく固まっているよりは、ずっと良いと思います。

---

稀にアプリを起動したらオンボーディング画面に遷移し、認証状況をチェックし、サインイン済みであればホーム画面に遷移する、といった挙動のアプリに遭遇します。
サインイン済みなのに一瞬オンボーディング画面が出るのって違和感ありますよね？特にネットワークが貧弱でなかなかアクセストークンが取得できないのか分かりませんが、しばらくオンボーディングの画面が出るアプリにも遭遇したことがあります。

この違和感を解消するためにも読み込み画面を挟み、認証状況なりをチェックしてから遷移させると良いと思います。

## go_router の `refreshListenable`と`redirect`で初期化後の画面遷移

go_router では、`refreshListenable`に`ValueNotifier`を渡すことで、値が変わった時にリダイレクトすることができます。

リダイレクトではアプリの初期化がまだなら `AppStartupWidget`に遷移させたり、サインイン状況を確認してオンボーディングかメイン画面に遷移させたりしています。
https://github.com/KoheiKanagu/blooms/blob/v1.0.1/app/lib/routing/application/my_go_router.dart#L50-L99

`refreshListenable`には `refreshListenableProvider`を渡しており、アプリの初期化状況や Firebase のサインイン状況、ユーザドキュメントの作成状況を監視しています。これらの値が変わったらリダイレクトが実行されます。
この方法のメリットとしては、アプリの初期化とユーザの認証状況に応じた画面遷移を一元管理することができる点です。
https://github.com/KoheiKanagu/blooms/blob/v1.0.1/app/lib/routing/domain/my_go_router_listenable.dart#L24-L69

これにより、どの画面にいても認証状況が変化したら特定の画面に遷移できます。
前述した`AppStartupWidget`では`appStartupProvider`が完了した後の画面について実装していませんでしたが、リダイレクトで所定の画面に遷移するので実装する必要はありません。
https://github.com/KoheiKanagu/blooms/blob/v1.0.1/app/lib/features/startup/presentation/startup_page.dart#L13-L24

### 強制サインアウトもできる

`refreshListenableProvider`ではユーザ個人のドキュメントの作成も監視しています。このドキュメントはいわゆるユーザ毎の情報で、名前などのプロフィールの記録を想定したものです。（[BLOOMS では作成日、更新日、削除日しかありません。](https://github.com/KoheiKanagu/blooms/blob/v1.0.1/firebase/firestore/schemas.yml#L17-L29)）

このドキュメントが作成されているかを監視しているので、ドキュメントを消せば強制的に即刻オンボーディング画面に遷移させることもできます

https://github.com/KoheiKanagu/blooms/blob/v1.0.1/app/lib/routing/domain/my_go_router_listenable.dart#L57-L66

[Firebase Authentication のリフレッシュトークンを revoke](https://firebase.google.com/docs/auth/admin/manage-sessions?hl=ja#revoke_refresh_tokens)しても良いと思いますが、アクセストークンが有効な 1 時間は利用できてしまうので、緊急性がある場合は先にユーザドキュメントを削除してキックした上で、revoke すると良いと思います。

一応、デバイスの紛失や盗難時における不正利用や、不正なユーザからのアクセスをブロックするための対策も兼ねているのですが、実際に使ったことはないので実用的かはなんとも分かりません。
後述しますが、サインインしたらユーザドキュメントを作る処理が完了したかどうかを監視するための用途が主です。

## サインインしたらユーザドキュメントを作る

[ユーザドキュメント](https://github.com/KoheiKanagu/blooms/blob/v1.0.1/firebase/firestore/schemas.yml#L17-L29)はユーザ毎の情報を保存していますが、サインインが完了したタイミングで Cloud Functions で作成すると良いと思います。

アプリでユーザドキュメントの作成を行う場合、もし作成に失敗したら進行不能になってしまいます。リトライしてなんとかしてもいいと思いますが、Cloud Functions で[Firebase Authentication トリガー](https://firebase.google.com/docs/functions/auth-events?hl=ja)を使って作成した方がシンプルだと思います。
また、アプリのバージョンによって作られるユーザドキュメントの内容が変わってしまう可能性もあるので、一元管理できる Cloud Functions で作成するのが良いと思います。

BLOOMS ではユーザドキュメントの作成に加え、いわゆるシードデータも作成しています。
https://github.com/KoheiKanagu/blooms/blob/v1.0.1/firebase/functions/src/features/auth/onCreateAuthUser.ts#L21-L53

前述した`refreshListenableProvider` ではこのユーザドキュメントを監視することでユーザドキュメントが作成されたらリダイレクトできます。

（ちなみに Firebase Authentication トリガーは未だに第 1 世代なのですが、[なんとかなりませんかね...](https://github.com/firebase/firebase-functions/issues/1383)）

### 匿名認証じゃない場合はブロッキング関数でも

ブロッキング関数を使えば、アプリに認証情報が渡る前になんらかの関数を実行することもできるので、Firebase Authentication トリガーを使わなくても同様のことが実現できます。
しかし、残念なことに[匿名認証では動作しません](https://firebase.google.com/docs/auth/extend-with-blocking-functions?hl=ja&gen=2nd#:~:text=%E5%8C%BF%E5%90%8D%E8%AA%8D%E8%A8%BC%E3%81%A8%E3%82%AB%E3%82%B9%E3%82%BF%E3%83%A0%E8%AA%8D%E8%A8%BC%E3%81%A7%E3%81%AF%E3%80%81%E3%83%96%E3%83%AD%E3%83%83%E3%82%AD%E3%83%B3%E3%82%B0%E9%96%A2%E6%95%B0%E3%81%AF%E3%83%88%E3%83%AA%E3%82%AC%E3%83%BC%E3%81%95%E3%82%8C%E3%81%BE%E3%81%9B%E3%82%93%E3%80%82)。

これはブロッキング関数のユースケースが特定のドメインのメールアドレスだけを許可したり、特定の IP アドレスからのサインインをブロックすることなので、匿名認証で動作しないのは仕方ない気がします。
https://firebase.google.com/docs/auth/extend-with-blocking-functions?hl=ja&gen=2nd

# ルーティング

シンプルなアプリであれば Navigator 1.0 だけでも十分ですが、認証に応じて画面遷移したかったり、ディープリンクをサポートしたかったり、何かしら柔軟なルーティングが必要な場合は Navigator 2.0 を利用すると良いと思います。
しかし Navigator 2.0 はそのまま使うととても難しいので、なんらかのパッケージを使うべきです。
https://medium.com/flutter/learning-flutters-new-navigation-and-routing-system-7c9068155ade

[go_router](https://pub.dev/packages/go_router)は Navigator 2.0 を簡単に使えるパッケージで、[利用者も多いですし Flutter 公式が開発している](https://pub.dev/packages/go_router/score)ので、デファクトスタンダードと言ってもいいでしょう。

とはいえ、Navigator 2.0 だけで全てのルーティングを行うのは至難の業だと思います。画面毎のパスの定義や画面間のデータの受け渡し、同じ画面を使い回すがパスが違う場合の対応など、意外にハマりどころが多いです。

私のおすすめは主要な画面だけ Navigator 2.0 で定義し、個別の画面は Navigator 1.0 を使う方法です。

## Navigator 2.0 と Navigator 1.0 の使い分け

BLOOMS では、アプリ起動直後に表示するローディングの`startup`、オンボーディングの`onboarding`、ホーム画面の`home`の 3 つだけを Navigator 2.0 で定義しています。
https://github.com/KoheiKanagu/blooms/blob/v1.0.1/app/lib/routing/application/my_go_router.dart#L30-L37

```log
[GoRouter] Full paths for routes:
           ├─/startup (Widget)
           ├─/onboarding (Widget)
           └─/home (Widget)
[GoRouter] setting initial location /startup
```

次の GIF にあるような画面遷移は Navigator 1.0 で行っています。

![Navigator 1.0での画面遷移](https://storage.googleapis.com/zenn-user-upload/9a51e3460fe1-20250219.webp =300x)
_Navigator 1.0 での画面遷移_

このように適材適所で使い分けた方が、ルーティングで考えることが減るので実装しやすいと思います。

## どの画面で Navigator 2.0 を使うのか

直接その画面に遷移したいかどうかで決めると良いと思います。

ディープリンクで直接特定の画面に遷移したいのであれば、その画面は Navigator 2.0 を使うべきです。一方で設定画面や詳細画面など、直接遷移しない画面は Navigator 1.0 で十分でしょう。

しかし、Web 対応する場合は URL の表現に違いが出てきます。Navigator 1.0 だと URL が変わらないため、同じ URL のまま画面遷移することになってしまいます。
この挙動をどう考えるかは要件次第ではありますが、気にしないのであれば Navigator 1.0 と Navigator 2.0 のハイブリッドが良いと思います。

# Flutter の状態管理

## Riverpod で状態管理

2024 年 12 月頃、[pub.dev でパッケージのダウンロード数が表示されるようになりました](https://medium.com/flutter/whats-new-in-flutter-3-27-28341129570c#:~:text=Package%20download%20counts%20on%20pub.dev)が、[Riverpod](https://pub.dev/packages/riverpod/score)と[Provider](https://pub.dev/packages/provider/score)が相当数ダウンロードされていることが判明しました。

私は[hooks_riverpod](https://pub.dev/packages/hooks_riverpod)を初め、[riverpod_generator](https://pub.dev/packages/riverpod_generator)も[使っています。](https://github.com/search?q=repo%3AKoheiKanagu%2Fblooms++path%3A**%2Fpubspec.yaml+riverpod&type=code)
Provider でできることは Riverpod でもできるはずなので、移行がまだの方は検討してみてはいかがでしょうか？

Riverpod の使い方やテクニック、いいところ悪いところ、他の状態管理との比較などは様々な記事があるので、みなさん各自で確認してください。ここで多くは語りません。

https://zenn.dev/topics/riverpod

https://codewithandrea.com/tags/riverpod/

https://medium.com/tag/riverpod

# [Dependabot](https://docs.github.com/ja/code-security/dependabot/working-with-dependabot) で依存パッケージをアップデート

依存しているパッケージって結構バージョンアップがあります。まだまだ枯れた技術ではないので、活発に開発されていることが伺えます。

私はよく毎週月曜日の明け方にチェックするように設定しているのですが、毎週何個もアップデートがあります。
https://github.com/KoheiKanagu/blooms/pulls?q=sort%3Aupdated-desc+is%3Apr+label%3Adependencies+is%3Amerged+

パッチ番号レベルのアップデートであれば自動でマージしても良いのですが、CHANGELOG を眺めて「開発されてんなー」と感じたいので手動でマージするようにしています。

Dependabot の設定におけるポイントは[groups](https://docs.github.com/ja/code-security/dependabot/working-with-dependabot/dependabot-options-reference#groups--)をきちんと定義することで、まとめてアップデートされたプルリクエストを作ってくれるようになります。

https://github.com/KoheiKanagu/blooms/blob/v1.0.1/.github/dependabot.yml#L19-L30

例えば Firebase 関連は[モノレポで管理](https://github.com/firebase/flutterfire/tree/main/packages)されていることもあってか、[まとめて一気にアップデート](https://github.com/KoheiKanagu/blooms/pull/213)されることが多いです。これら一つ一つが別々のプルリクエストになると CI の実行時間も延びますし、マージされる順番によってはリベースが必要になってなかなかマージされない事態になります。

---

[Renovate](https://github.com/renovatebot/renovate)も選択肢の一つです。Dependabot に比べて[カスタマイズできる幅が広いので](https://github.com/KoheiKanagu/garage/blob/main/renovate.json)、細かくカスタマイズしたい場合はこちらを使うと良いかもしれません。

ただセットアップがやや面倒なので、とりあえずアップデートをチェックしたいということであれば Dependabot の方がお手軽だと思います。

# 関係するファイルが更新された時だけ GitHub Actions のジョブは実行しよう

BLOOMS のリポジトリには、[アプリ](https://github.com/KoheiKanagu/blooms/tree/v1.0.1/app)とサーバサイドである[Firebase 関連](https://github.com/KoheiKanagu/blooms/tree/v1.0.1/firebase)が共存しています。そのためアプリに関するソースコードだけを変更する場合と、Firebase 関連だけを変更する場合があります。

アプリに関するソースコードだけを修正した場合、Firebase 関連には変更がないので、Firebase 関連に対するジョブは必ずしも実行する必要はありません。逆もまた然りです。アプリに関するジョブは比較的時間がかかるので、できれば関係ない時は実行したくありません。

そこで、[Changed Files](https://github.com/marketplace/actions/changed-files)アクションを使って関連するファイルが更新された時だけ、所定のジョブを実行するようにしています。
アプリに関する`app`、Firebase 関連に関する`firebase`、アプリの pubspec.yaml の変更に関する`pubspec`を定義しています。
https://github.com/KoheiKanagu/blooms/blob/ce956da252c0f21000f759ac172498225701b6ca/.github/workflows/pull_request.yml#L24-L35

`changed-files.outputs`より、それぞれの変更の有無を取得できるので、必要なジョブだけを実行することができます。

https://github.com/KoheiKanagu/blooms/blob/ce956da252c0f21000f759ac172498225701b6ca/.github/workflows/pull_request.yml#L61-L62

## 実際のワークフロー実行時間の比較

例えば次の画像は`app/**`に変更を行ったプルリクエストのワークフローの様子です。

右上の[`check_cloud_functions`](https://github.com/KoheiKanagu/blooms/blob/ce956da252c0f21000f759ac172498225701b6ca/.github/workflows/pull_request.yml#L139)は Cloud Functions のテストを実行するジョブなのですが、4 秒で完了しています。これはランナーは起動したが、テストを実行する必要がなったのですぐに終了したことを示しています。

一方で アプリに関するジョブである[`Matrix: check_app`](https://github.com/KoheiKanagu/blooms/blob/ce956da252c0f21000f759ac172498225701b6ca/.github/workflows/pull_request.yml#L37-L59)は、数十秒から 3 分程度のジョブがそれぞれ並列に実行されています。
よって`changed-files`ジョブの時間も含めると、このワークフローが完了するまでには 3 分 7 秒必要でした。

![`app/**`に変更を行ったプルリクエストのワークフローの様子](https://storage.googleapis.com/zenn-user-upload/179a9dce1bf6-20250222.png)
_`app/**`に変更を行ったプルリクエストのワークフローの様子_

逆に、`firebase/**`に変更を行ったプルリクエストのワークフローの様子を見てみましょう。

次の画像にあるように`check_cloud_functions`は 51 秒かかっていますが、`Matrix: check_app`は 5 秒以内に完了しています。
よって`changed-files`ジョブの時間も含めると、このワークフローが完了するまでには 55 秒必要でした。

![`firebase/**`に変更を行ったプルリクエストのワークフローの様子](https://storage.googleapis.com/zenn-user-upload/e0a116455a62-20250222.png)
_`firebase/**`に変更を行ったプルリクエストのワークフローの様子_

## ただし数秒のジョブはコスパ最悪

数秒で終わるジョブをたくさん作るのはコストの面では最悪です。

GitHub Actions では実行時間の[秒単位は分に切り上げられてしまう](https://docs.github.com/ja/billing/managing-billing-for-your-products/managing-billing-for-github-actions/about-billing-for-github-actions#:~:text=GitHub%20%E3%81%AF%E3%80%81%E5%90%84%E3%82%B8%E3%83%A7%E3%83%96%E3%81%8C%E4%BD%BF%E3%81%A3%E3%81%9F%E5%88%86%E3%81%A8%E5%88%86%E6%9C%AA%E6%BA%80%E3%82%92%E3%82%82%E3%81%A3%E3%81%A8%E3%82%82%E8%BF%91%E3%81%84%E5%88%86%E3%81%AB%E5%88%87%E3%82%8A%E4%B8%8A%E3%81%92%E3%81%BE%E3%81%99%E3%80%82)ので、たとえ 1 秒のジョブでも 1 分としてカウントされてしまいます。
よって、前述のように`Matrix: check_app`で 6 つのジョブが数秒で終わったとしても、6 分としてカウントされています。

もう少しコスト面を考慮するなら`Matrix: check_app`は 1 つのジョブにまとめ、さらに`changed-files`に相当する処理を`check_cloud_functions`や`check_app`ジョブ内で実行すると良いと思います。

`changed-files`を前段のジョブにして、かつ数秒で完了する可能性のあるジョブを並列に実行するのは、GitHub Actions が[パブリックリポジトリでは無料](https://docs.github.com/ja/billing/managing-billing-for-your-products/managing-billing-for-github-actions/about-billing-for-github-actions#:~:text=GitHub%20Actions%20%E3%81%AE%E4%BD%BF%E7%94%A8%E3%81%AF%E3%80%81%E3%83%91%E3%83%96%E3%83%AA%E3%83%83%E3%82%AF%20%E3%83%AA%E3%83%9D%E3%82%B8%E3%83%88%E3%83%AA%E3%81%AE%E6%A8%99%E6%BA%96%E3%81%AE%20GitHub%20%E3%83%9B%E3%82%B9%E3%83%86%E3%83%83%E3%83%89%20%E3%83%A9%E3%83%B3%E3%83%8A%E3%83%BC%E3%81%A8%E3%82%BB%E3%83%AB%E3%83%95%E3%83%9B%E3%82%B9%E3%83%86%E3%83%83%E3%83%89%20%E3%83%A9%E3%83%B3%E3%83%8A%E3%83%BC%E3%81%AE%E5%A0%B4%E5%90%88%E3%81%AF%E7%84%A1%E6%96%99%E3%81%A7%E3%81%99%E3%80%82)であるからこそ気にせず使えるテクニックであると言えます。

### [`on.pull_request.paths`](https://docs.github.com/ja/actions/writing-workflows/workflow-syntax-for-github-actions#onpushpull_requestpull_request_targetpathspaths-ignore)を使えばいいのでは？

`on.pull_request.paths`を使う方法も考えられますが、これはワークフロー自体の実行をスキップしてしまいます。

実行のスキップは、特定のジョブが成功しないとプルリクエストをマージできないようにする、[ブランチ保護ルール](https://docs.github.com/ja/repositories/configuring-branches-and-merges-in-your-repository/managing-protected-branches/managing-a-branch-protection-rule)の[ステータスチェック](https://docs.github.com/ja/repositories/configuring-branches-and-merges-in-your-repository/managing-protected-branches/about-protected-branches#require-status-checks-before-merging)との相性が悪いです。
ステータスチェックではワークフローは実行した上で OK か NG かを判定するので、`on.pull_request.paths`を使うとワークフローが実行されないため、ステータスチェックが通らないという事態になります。

（スキップされた場合は OK とみなす、といったステータスチェックは定義できないはずです）

# おわりに

BLOOMS を作りながらメモしていたことを一通り書きました。

想定より長文になってしまったので全て目を通していただくのは大変だと思いますが、何かしら参考になる部分があれば幸いです。他にも何か思い出したら追記するかもしれません。

ご質問等ありましたら、お気軽にコメントいただければと思います。

以上です。
